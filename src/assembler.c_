#include "assembler.h"

void firstPass(State * state, FILE * file);
void secondPass(State * state, FILE * file);
void resetState(State * state);
void logState(const State * state);
void generateOutputs(State * state, const char * baseName);
void createFileName(char * destination, const char * baseName, const char * extension);

void assembleInput(const char * baseName) {
    /* assembler state to be carried on through the process */
    State state;
    FILE * sourceFile;
    char filePath[MAX_FILE_PATH_LENGTH];

    /* initialize to a known state, determined elsewhere */
    resetState(&state);

    logInfo("Processing: %s", baseName);

    createFileName(filePath, baseName, "as");
    logDebug("File name assumed to be: %s", filePath);

    sourceFile = fopen(filePath, "r");
    if (sourceFile == NULL){
        logError("Could not open file: %s. Aborting", filePath);
        return;
    }

    firstPass(&state, sourceFile);
    if (state.firstPassSuccess){
        /* rewind file */
        fseek(sourceFile, 0, SEEK_SET);
        secondPass(&state, sourceFile);
    }

    fclose(sourceFile);
    if (state.secondPassSuccess){
        generateOutputs(&state, baseName);
    }
}

void firstPass(State * state, FILE * file) {

    ParsedDirective parsedDirective;
    unsigned int lineNumber;
    char line[MAX_LINE_LENGTH + 1];

    lineNumber = 1;

    while (fgets(line, MAX_LINE_LENGTH, file) != NULL){
        /* remove the newline at the end */
        line[strlen(line) - 1] = '\0';

        if (!isEmptyLine(line) && !isCommentLine(line)){
            logDebug("should manage line%5d: %s", lineNumber, line);
            parsedDirective = tryParseDirectiveLine(line);

            switch (parsedDirective.directiveType){
                case DIRECTIVE_TYPE_NOT_DIRECTIVE:
                    logDebug("not directive, maybe instruction");
                    break;
                case DIRECTIVE_TYPE_INVALID:
                    logError("invalid directive type line%5d: %s", lineNumber, line);
                    break;
                case DIRECTIVE_TYPE_DATA:
                case DIRECTIVE_TYPE_STRING:
                    if (parsedDirective.arguments == NULL){
                        logError("invalid arguments line%5d: %s", lineNumber, line);
                    } else {
                    }
                    break;
                case DIRECTIVE_TYPE_ENTRY:
                case DIRECTIVE_TYPE_EXTERN:
                    break;
            }
        }

        ++lineNumber;
    }

    logWarning("assemblerRunFirstPass::NotImplemented");
}

void secondPass(State * state, FILE * file) {
    logError("assemblerRunSecondPass::NotImplemented");
}

void resetState(State * state) {
    logDebug("Resetting state");
    state->IC = 0;
    state->DC = 0;
    state->firstPassSuccess = false;
    state->secondPassSuccess = false;
}

void logState(const State * state){
    logDebug("State(IC=%d, DC=%d)", state->IC, state->DC);
}


void generateOutputs(State * state, const char * baseName) {
    logError("assemblerGenerateOutputs::NotImplemented");
}

void createFileName(char * destination, const char * baseName, const char * extension) {
    strcpy(destination, baseName);
    strcat(destination, ".");
    strcat(destination, extension);
}